<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>scenographer.relations API documentation</title>
<meta name="description" content="RelationDAG" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scenographer.relations</code></h1>
</header>
<section id="section-intro">
<p>RelationDAG</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
RelationDAG
&#34;&#34;&#34;

from functools import lru_cache
from typing import Iterable, List, Mapping, NamedTuple, Tuple, Type

import matplotlib.pyplot as plot
import networkx
from loguru import logger
from networkx import DiGraph
from sqlalchemy import ForeignKey, MetaData
from sqlalchemy.schema import Column, Table
from sqlalchemy_utils import get_referencing_foreign_keys

from scenographer.database import Database, UUIDField


class Relation(NamedTuple):
    &#34;Container for the associated pair of primary key and foreign key&#34;
    pk: Column
    fk: Column

    @property
    def edge(self) -&gt; Tuple[Table, Table, Mapping[str, Column]]:
        &#34;Returns a tuple that is accepted by networkx lib as a graph edge&#34;
        return (self.pk.table, self.fk.table, {&#34;relation&#34;: self})

    def __repr__(self) -&gt; str:
        &#34;REPL representation of a relation&#34;
        relation_kwargs = [
            f&#34;pk=database_tables.{self.pk.table.name}.c.{self.pk.name}&#34;,
            f&#34;fk=database_tables.{self.fk.table.name}.c.{self.fk.name}&#34;,
        ]

        return f&#34;Relation({&#39;,&#39;.join(relation_kwargs)})&#34;

    @classmethod
    def from_foreign_key(cls: Type[&#34;Relation&#34;], foreign_key: ForeignKey) -&gt; &#34;Relation&#34;:
        &#34;Constructor for a relation given a ForeignKey object&#34;
        return cls(
            pk=foreign_key.column,  # referenced column
            fk=foreign_key.parent,  # referer column
        )

    @classmethod
    def from_tables(cls: Type[&#34;Relation&#34;], tables: List[Table]) -&gt; List[&#34;Relation&#34;]:
        &#34;&#34;&#34;
        Constructor for a list of relations given a table
        Creates one relation for each foreign_key constraint associated with the table
        &#34;&#34;&#34;
        return [
            cls.from_foreign_key(fk)
            for table in tables
            for fk in get_referencing_foreign_keys(table)
        ]


class RelationDAG(NamedTuple):
    &#34;Wrapper for operations around the graph of relations&#34;
    graph: DiGraph

    @property
    @lru_cache()
    def tables(self) -&gt; List[Table]:
        &#34;Lists all tables taken into consideration for sampling&#34;
        return self.graph.nodes

    @property
    @lru_cache()
    def entrypoints(self) -&gt; List[Table]:
        &#34;Lists tables which have no foreign keys&#34;
        return [n for (n, d) in self.graph.in_degree(self.graph.nodes) if d == 0]

    @property
    @lru_cache()
    def topologically_sorted(self) -&gt; Iterable[Table]:
        &#34;&#34;&#34;
        Returns all tables ordered in a way that
        if table X has a foreign key to Y, Y will always come first
        &#34;&#34;&#34;
        return networkx.topological_sort(self.graph)

    def write_plot(self, filepath: str = &#34;graph.png&#34;) -&gt; None:
        &#34;Meh graph image representation&#34;
        logger.debug(&#34;Writing image file with graph&#34;)
        plot.title(&#34;RelationDAG&#34;)
        pos = networkx.drawing.nx_agraph.graphviz_layout(self.graph, prog=&#34;dot&#34;)
        plot.figure(figsize=(40, 40))

        networkx.draw_networkx_nodes(self.graph, pos, node_size=5000, alpha=0.9)
        networkx.draw_networkx_edges(
            self.graph, pos, arrows=True, node_size=5000,
        )
        networkx.draw_networkx_labels(self.graph, pos)

        plot.axis(&#34;off&#34;)
        plot.savefig(filepath)

    def write_dot(self, filepath: str = &#34;graph.dot&#34;) -&gt; None:
        &#34;Meh graph image representation. File must be rendered with `dot`&#34;
        logger.debug(&#34;Writing dot file with graph&#34;)
        networkx.drawing.nx_agraph.write_dot(self.graph, filepath)

    @property
    @lru_cache()
    def key_schema(self) -&gt; MetaData:
        &#34;&#34;&#34;
        Create schema with only the primary keys and foreign keys of each table.
        Ensures that the resulting schema is compatible with sqlite3
        &#34;&#34;&#34;
        metadata = MetaData()

        for table in self.graph.nodes:

            # Here we use edge data for the first (only ?) time.
            # Perhaps we can shape the data better to avoid doing work here.

            # Select the relations whose foreign keys are present in this table
            relations = [
                edge[-1][&#34;relation&#34;]
                for edge in self.graph.reverse(copy=False).edges(
                    nbunch=table, data=True
                )
            ]

            # We get PK from table data instead of relation data,
            # because a primary key doesn&#39;t necessarily form a relation.
            # Assumes PK either is a single column or it doesn&#39;t exist.
            primary_key = [
                Column(c.name, c.type, primary_key=True)
                for c in table.primary_key.columns
            ][:1]

            columns = [
                *primary_key,
                *[
                    Column(r.fk.name, r.fk.type, ForeignKey(str(r.pk)))
                    for r in relations
                ],
            ]

            # Map postgres UUIDs into sqlite compatible UUIDs
            for column in columns:
                if str(column.type) not in [&#34;UUID&#34;, &#34;BIGINT&#34;, &#34;INTEGER&#34;]:
                    logger.warning(
                        &#34;Key column {} has weird type {}&#34;,
                        f&#34;{table.name}.{column.name}&#34;,
                        str(column.type),
                    )
                if str(column.type) == &#34;UUID&#34;:
                    column.type = UUIDField()

            Table(table.name, metadata, *columns)

        return metadata

    @classmethod
    def from_graph(cls: Type[&#34;RelationDAG&#34;], graph: DiGraph) -&gt; &#34;RelationDAG&#34;:
        &#34;&#34;&#34;
        Instanciates a RelationDAG from a networkx DiGraph.
        It makes the graph is immutable and raises if the graph is not a DAG
        &#34;&#34;&#34;
        new = cls(networkx.freeze(graph))
        if networkx.is_directed_acyclic_graph(new.graph):
            logger.debug(
                &#34;DAG contains {} nodes and {} edges&#34;,
                len(graph.nodes),
                len(graph.edges),
            )
        else:
            logger.error(&#34;Generated graph is not a DAG.&#34;)
            raise ValueError

        return new

    @classmethod
    def load(
        cls: Type[&#34;RelationDAG&#34;],
        database: Database,
        extend_relations: List[Relation],
        ignore_relations: List[Relation],
        ignore_tables: List[Table],
    ) -&gt; &#34;RelationDAG&#34;:
        &#34;&#34;&#34;
        Create a RelationDAG
        The data loaded from this method is sourced
        from the database and from the user config
        &#34;&#34;&#34;
        graph = DiGraph(name=&#34;RelationDAG&#34;)

        # Get actual table instances
        tables = database.tables.__dict__.values()

        # Create relations from table data and add the ones specified in settings
        relations = Relation.from_tables(tables) + extend_relations

        # Create graph
        graph.add_nodes_from(tables)
        graph.add_edges_from([r.edge for r in relations])

        # Remove excluded entities (tables and relations) from the created graph
        graph.remove_edges_from([r.edge for r in ignore_relations])
        graph.remove_nodes_from(ignore_tables)

        # Create RelationDAG instance
        return cls.from_graph(graph)

    def __str__(self) -&gt; str:
        &#34;Return some useful information about the graph&#34;
        return networkx.info(self.graph)

    def __repr__(self) -&gt; str:
        &#34;For REPL use. Should work with only RelationDAG in scope.&#34;
        return &#34;RelationDAG&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scenographer.relations.Relation"><code class="flex name class">
<span>class <span class="ident">Relation</span></span>
<span>(</span><span>pk, fk)</span>
</code></dt>
<dd>
<section class="desc"><p>Container for the associated pair of primary key and foreign key</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Relation(NamedTuple):
    &#34;Container for the associated pair of primary key and foreign key&#34;
    pk: Column
    fk: Column

    @property
    def edge(self) -&gt; Tuple[Table, Table, Mapping[str, Column]]:
        &#34;Returns a tuple that is accepted by networkx lib as a graph edge&#34;
        return (self.pk.table, self.fk.table, {&#34;relation&#34;: self})

    def __repr__(self) -&gt; str:
        &#34;REPL representation of a relation&#34;
        relation_kwargs = [
            f&#34;pk=database_tables.{self.pk.table.name}.c.{self.pk.name}&#34;,
            f&#34;fk=database_tables.{self.fk.table.name}.c.{self.fk.name}&#34;,
        ]

        return f&#34;Relation({&#39;,&#39;.join(relation_kwargs)})&#34;

    @classmethod
    def from_foreign_key(cls: Type[&#34;Relation&#34;], foreign_key: ForeignKey) -&gt; &#34;Relation&#34;:
        &#34;Constructor for a relation given a ForeignKey object&#34;
        return cls(
            pk=foreign_key.column,  # referenced column
            fk=foreign_key.parent,  # referer column
        )

    @classmethod
    def from_tables(cls: Type[&#34;Relation&#34;], tables: List[Table]) -&gt; List[&#34;Relation&#34;]:
        &#34;&#34;&#34;
        Constructor for a list of relations given a table
        Creates one relation for each foreign_key constraint associated with the table
        &#34;&#34;&#34;
        return [
            cls.from_foreign_key(fk)
            for table in tables
            for fk in get_referencing_foreign_keys(table)
        ]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenographer.relations.Relation.from_foreign_key"><code class="name flex">
<span>def <span class="ident">from_foreign_key</span></span>(<span>foreign_key)</span>
</code></dt>
<dd>
<section class="desc"><p>Constructor for a relation given a ForeignKey object</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_foreign_key(cls: Type[&#34;Relation&#34;], foreign_key: ForeignKey) -&gt; &#34;Relation&#34;:
    &#34;Constructor for a relation given a ForeignKey object&#34;
    return cls(
        pk=foreign_key.column,  # referenced column
        fk=foreign_key.parent,  # referer column
    )</code></pre>
</details>
</dd>
<dt id="scenographer.relations.Relation.from_tables"><code class="name flex">
<span>def <span class="ident">from_tables</span></span>(<span>tables)</span>
</code></dt>
<dd>
<section class="desc"><p>Constructor for a list of relations given a table
Creates one relation for each foreign_key constraint associated with the table</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_tables(cls: Type[&#34;Relation&#34;], tables: List[Table]) -&gt; List[&#34;Relation&#34;]:
    &#34;&#34;&#34;
    Constructor for a list of relations given a table
    Creates one relation for each foreign_key constraint associated with the table
    &#34;&#34;&#34;
    return [
        cls.from_foreign_key(fk)
        for table in tables
        for fk in get_referencing_foreign_keys(table)
    ]</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="scenographer.relations.Relation.edge"><code class="name">var <span class="ident">edge</span></code></dt>
<dd>
<section class="desc"><p>Returns a tuple that is accepted by networkx lib as a graph edge</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def edge(self) -&gt; Tuple[Table, Table, Mapping[str, Column]]:
    &#34;Returns a tuple that is accepted by networkx lib as a graph edge&#34;
    return (self.pk.table, self.fk.table, {&#34;relation&#34;: self})</code></pre>
</details>
</dd>
<dt id="scenographer.relations.Relation.fk"><code class="name">var <span class="ident">fk</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 1</p></section>
</dd>
<dt id="scenographer.relations.Relation.pk"><code class="name">var <span class="ident">pk</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
</dd>
</dl>
</dd>
<dt id="scenographer.relations.RelationDAG"><code class="flex name class">
<span>class <span class="ident">RelationDAG</span></span>
<span>(</span><span>graph)</span>
</code></dt>
<dd>
<section class="desc"><p>Wrapper for operations around the graph of relations</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RelationDAG(NamedTuple):
    &#34;Wrapper for operations around the graph of relations&#34;
    graph: DiGraph

    @property
    @lru_cache()
    def tables(self) -&gt; List[Table]:
        &#34;Lists all tables taken into consideration for sampling&#34;
        return self.graph.nodes

    @property
    @lru_cache()
    def entrypoints(self) -&gt; List[Table]:
        &#34;Lists tables which have no foreign keys&#34;
        return [n for (n, d) in self.graph.in_degree(self.graph.nodes) if d == 0]

    @property
    @lru_cache()
    def topologically_sorted(self) -&gt; Iterable[Table]:
        &#34;&#34;&#34;
        Returns all tables ordered in a way that
        if table X has a foreign key to Y, Y will always come first
        &#34;&#34;&#34;
        return networkx.topological_sort(self.graph)

    def write_plot(self, filepath: str = &#34;graph.png&#34;) -&gt; None:
        &#34;Meh graph image representation&#34;
        logger.debug(&#34;Writing image file with graph&#34;)
        plot.title(&#34;RelationDAG&#34;)
        pos = networkx.drawing.nx_agraph.graphviz_layout(self.graph, prog=&#34;dot&#34;)
        plot.figure(figsize=(40, 40))

        networkx.draw_networkx_nodes(self.graph, pos, node_size=5000, alpha=0.9)
        networkx.draw_networkx_edges(
            self.graph, pos, arrows=True, node_size=5000,
        )
        networkx.draw_networkx_labels(self.graph, pos)

        plot.axis(&#34;off&#34;)
        plot.savefig(filepath)

    def write_dot(self, filepath: str = &#34;graph.dot&#34;) -&gt; None:
        &#34;Meh graph image representation. File must be rendered with `dot`&#34;
        logger.debug(&#34;Writing dot file with graph&#34;)
        networkx.drawing.nx_agraph.write_dot(self.graph, filepath)

    @property
    @lru_cache()
    def key_schema(self) -&gt; MetaData:
        &#34;&#34;&#34;
        Create schema with only the primary keys and foreign keys of each table.
        Ensures that the resulting schema is compatible with sqlite3
        &#34;&#34;&#34;
        metadata = MetaData()

        for table in self.graph.nodes:

            # Here we use edge data for the first (only ?) time.
            # Perhaps we can shape the data better to avoid doing work here.

            # Select the relations whose foreign keys are present in this table
            relations = [
                edge[-1][&#34;relation&#34;]
                for edge in self.graph.reverse(copy=False).edges(
                    nbunch=table, data=True
                )
            ]

            # We get PK from table data instead of relation data,
            # because a primary key doesn&#39;t necessarily form a relation.
            # Assumes PK either is a single column or it doesn&#39;t exist.
            primary_key = [
                Column(c.name, c.type, primary_key=True)
                for c in table.primary_key.columns
            ][:1]

            columns = [
                *primary_key,
                *[
                    Column(r.fk.name, r.fk.type, ForeignKey(str(r.pk)))
                    for r in relations
                ],
            ]

            # Map postgres UUIDs into sqlite compatible UUIDs
            for column in columns:
                if str(column.type) not in [&#34;UUID&#34;, &#34;BIGINT&#34;, &#34;INTEGER&#34;]:
                    logger.warning(
                        &#34;Key column {} has weird type {}&#34;,
                        f&#34;{table.name}.{column.name}&#34;,
                        str(column.type),
                    )
                if str(column.type) == &#34;UUID&#34;:
                    column.type = UUIDField()

            Table(table.name, metadata, *columns)

        return metadata

    @classmethod
    def from_graph(cls: Type[&#34;RelationDAG&#34;], graph: DiGraph) -&gt; &#34;RelationDAG&#34;:
        &#34;&#34;&#34;
        Instanciates a RelationDAG from a networkx DiGraph.
        It makes the graph is immutable and raises if the graph is not a DAG
        &#34;&#34;&#34;
        new = cls(networkx.freeze(graph))
        if networkx.is_directed_acyclic_graph(new.graph):
            logger.debug(
                &#34;DAG contains {} nodes and {} edges&#34;,
                len(graph.nodes),
                len(graph.edges),
            )
        else:
            logger.error(&#34;Generated graph is not a DAG.&#34;)
            raise ValueError

        return new

    @classmethod
    def load(
        cls: Type[&#34;RelationDAG&#34;],
        database: Database,
        extend_relations: List[Relation],
        ignore_relations: List[Relation],
        ignore_tables: List[Table],
    ) -&gt; &#34;RelationDAG&#34;:
        &#34;&#34;&#34;
        Create a RelationDAG
        The data loaded from this method is sourced
        from the database and from the user config
        &#34;&#34;&#34;
        graph = DiGraph(name=&#34;RelationDAG&#34;)

        # Get actual table instances
        tables = database.tables.__dict__.values()

        # Create relations from table data and add the ones specified in settings
        relations = Relation.from_tables(tables) + extend_relations

        # Create graph
        graph.add_nodes_from(tables)
        graph.add_edges_from([r.edge for r in relations])

        # Remove excluded entities (tables and relations) from the created graph
        graph.remove_edges_from([r.edge for r in ignore_relations])
        graph.remove_nodes_from(ignore_tables)

        # Create RelationDAG instance
        return cls.from_graph(graph)

    def __str__(self) -&gt; str:
        &#34;Return some useful information about the graph&#34;
        return networkx.info(self.graph)

    def __repr__(self) -&gt; str:
        &#34;For REPL use. Should work with only RelationDAG in scope.&#34;
        return &#34;RelationDAG&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scenographer.relations.RelationDAG.from_graph"><code class="name flex">
<span>def <span class="ident">from_graph</span></span>(<span>graph)</span>
</code></dt>
<dd>
<section class="desc"><p>Instanciates a RelationDAG from a networkx DiGraph.
It makes the graph is immutable and raises if the graph is not a DAG</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_graph(cls: Type[&#34;RelationDAG&#34;], graph: DiGraph) -&gt; &#34;RelationDAG&#34;:
    &#34;&#34;&#34;
    Instanciates a RelationDAG from a networkx DiGraph.
    It makes the graph is immutable and raises if the graph is not a DAG
    &#34;&#34;&#34;
    new = cls(networkx.freeze(graph))
    if networkx.is_directed_acyclic_graph(new.graph):
        logger.debug(
            &#34;DAG contains {} nodes and {} edges&#34;,
            len(graph.nodes),
            len(graph.edges),
        )
    else:
        logger.error(&#34;Generated graph is not a DAG.&#34;)
        raise ValueError

    return new</code></pre>
</details>
</dd>
<dt id="scenographer.relations.RelationDAG.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>database, extend_relations, ignore_relations, ignore_tables)</span>
</code></dt>
<dd>
<section class="desc"><p>Create a RelationDAG
The data loaded from this method is sourced
from the database and from the user config</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def load(
    cls: Type[&#34;RelationDAG&#34;],
    database: Database,
    extend_relations: List[Relation],
    ignore_relations: List[Relation],
    ignore_tables: List[Table],
) -&gt; &#34;RelationDAG&#34;:
    &#34;&#34;&#34;
    Create a RelationDAG
    The data loaded from this method is sourced
    from the database and from the user config
    &#34;&#34;&#34;
    graph = DiGraph(name=&#34;RelationDAG&#34;)

    # Get actual table instances
    tables = database.tables.__dict__.values()

    # Create relations from table data and add the ones specified in settings
    relations = Relation.from_tables(tables) + extend_relations

    # Create graph
    graph.add_nodes_from(tables)
    graph.add_edges_from([r.edge for r in relations])

    # Remove excluded entities (tables and relations) from the created graph
    graph.remove_edges_from([r.edge for r in ignore_relations])
    graph.remove_nodes_from(ignore_tables)

    # Create RelationDAG instance
    return cls.from_graph(graph)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="scenographer.relations.RelationDAG.entrypoints"><code class="name">var <span class="ident">entrypoints</span></code></dt>
<dd>
<section class="desc"><p>Lists tables which have no foreign keys</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@lru_cache()
def entrypoints(self) -&gt; List[Table]:
    &#34;Lists tables which have no foreign keys&#34;
    return [n for (n, d) in self.graph.in_degree(self.graph.nodes) if d == 0]</code></pre>
</details>
</dd>
<dt id="scenographer.relations.RelationDAG.graph"><code class="name">var <span class="ident">graph</span></code></dt>
<dd>
<section class="desc"><p>Alias for field number 0</p></section>
</dd>
<dt id="scenographer.relations.RelationDAG.key_schema"><code class="name">var <span class="ident">key_schema</span></code></dt>
<dd>
<section class="desc"><p>Create schema with only the primary keys and foreign keys of each table.
Ensures that the resulting schema is compatible with sqlite3</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@lru_cache()
def key_schema(self) -&gt; MetaData:
    &#34;&#34;&#34;
    Create schema with only the primary keys and foreign keys of each table.
    Ensures that the resulting schema is compatible with sqlite3
    &#34;&#34;&#34;
    metadata = MetaData()

    for table in self.graph.nodes:

        # Here we use edge data for the first (only ?) time.
        # Perhaps we can shape the data better to avoid doing work here.

        # Select the relations whose foreign keys are present in this table
        relations = [
            edge[-1][&#34;relation&#34;]
            for edge in self.graph.reverse(copy=False).edges(
                nbunch=table, data=True
            )
        ]

        # We get PK from table data instead of relation data,
        # because a primary key doesn&#39;t necessarily form a relation.
        # Assumes PK either is a single column or it doesn&#39;t exist.
        primary_key = [
            Column(c.name, c.type, primary_key=True)
            for c in table.primary_key.columns
        ][:1]

        columns = [
            *primary_key,
            *[
                Column(r.fk.name, r.fk.type, ForeignKey(str(r.pk)))
                for r in relations
            ],
        ]

        # Map postgres UUIDs into sqlite compatible UUIDs
        for column in columns:
            if str(column.type) not in [&#34;UUID&#34;, &#34;BIGINT&#34;, &#34;INTEGER&#34;]:
                logger.warning(
                    &#34;Key column {} has weird type {}&#34;,
                    f&#34;{table.name}.{column.name}&#34;,
                    str(column.type),
                )
            if str(column.type) == &#34;UUID&#34;:
                column.type = UUIDField()

        Table(table.name, metadata, *columns)

    return metadata</code></pre>
</details>
</dd>
<dt id="scenographer.relations.RelationDAG.tables"><code class="name">var <span class="ident">tables</span></code></dt>
<dd>
<section class="desc"><p>Lists all tables taken into consideration for sampling</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@lru_cache()
def tables(self) -&gt; List[Table]:
    &#34;Lists all tables taken into consideration for sampling&#34;
    return self.graph.nodes</code></pre>
</details>
</dd>
<dt id="scenographer.relations.RelationDAG.topologically_sorted"><code class="name">var <span class="ident">topologically_sorted</span></code></dt>
<dd>
<section class="desc"><p>Returns all tables ordered in a way that
if table X has a foreign key to Y, Y will always come first</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@lru_cache()
def topologically_sorted(self) -&gt; Iterable[Table]:
    &#34;&#34;&#34;
    Returns all tables ordered in a way that
    if table X has a foreign key to Y, Y will always come first
    &#34;&#34;&#34;
    return networkx.topological_sort(self.graph)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scenographer.relations.RelationDAG.write_dot"><code class="name flex">
<span>def <span class="ident">write_dot</span></span>(<span>self, filepath='graph.dot')</span>
</code></dt>
<dd>
<section class="desc"><p>Meh graph image representation. File must be rendered with <code>dot</code></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_dot(self, filepath: str = &#34;graph.dot&#34;) -&gt; None:
    &#34;Meh graph image representation. File must be rendered with `dot`&#34;
    logger.debug(&#34;Writing dot file with graph&#34;)
    networkx.drawing.nx_agraph.write_dot(self.graph, filepath)</code></pre>
</details>
</dd>
<dt id="scenographer.relations.RelationDAG.write_plot"><code class="name flex">
<span>def <span class="ident">write_plot</span></span>(<span>self, filepath='graph.png')</span>
</code></dt>
<dd>
<section class="desc"><p>Meh graph image representation</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_plot(self, filepath: str = &#34;graph.png&#34;) -&gt; None:
    &#34;Meh graph image representation&#34;
    logger.debug(&#34;Writing image file with graph&#34;)
    plot.title(&#34;RelationDAG&#34;)
    pos = networkx.drawing.nx_agraph.graphviz_layout(self.graph, prog=&#34;dot&#34;)
    plot.figure(figsize=(40, 40))

    networkx.draw_networkx_nodes(self.graph, pos, node_size=5000, alpha=0.9)
    networkx.draw_networkx_edges(
        self.graph, pos, arrows=True, node_size=5000,
    )
    networkx.draw_networkx_labels(self.graph, pos)

    plot.axis(&#34;off&#34;)
    plot.savefig(filepath)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scenographer" href="index.html">scenographer</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scenographer.relations.Relation" href="#scenographer.relations.Relation">Relation</a></code></h4>
<ul class="">
<li><code><a title="scenographer.relations.Relation.edge" href="#scenographer.relations.Relation.edge">edge</a></code></li>
<li><code><a title="scenographer.relations.Relation.fk" href="#scenographer.relations.Relation.fk">fk</a></code></li>
<li><code><a title="scenographer.relations.Relation.from_foreign_key" href="#scenographer.relations.Relation.from_foreign_key">from_foreign_key</a></code></li>
<li><code><a title="scenographer.relations.Relation.from_tables" href="#scenographer.relations.Relation.from_tables">from_tables</a></code></li>
<li><code><a title="scenographer.relations.Relation.pk" href="#scenographer.relations.Relation.pk">pk</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scenographer.relations.RelationDAG" href="#scenographer.relations.RelationDAG">RelationDAG</a></code></h4>
<ul class="">
<li><code><a title="scenographer.relations.RelationDAG.entrypoints" href="#scenographer.relations.RelationDAG.entrypoints">entrypoints</a></code></li>
<li><code><a title="scenographer.relations.RelationDAG.from_graph" href="#scenographer.relations.RelationDAG.from_graph">from_graph</a></code></li>
<li><code><a title="scenographer.relations.RelationDAG.graph" href="#scenographer.relations.RelationDAG.graph">graph</a></code></li>
<li><code><a title="scenographer.relations.RelationDAG.key_schema" href="#scenographer.relations.RelationDAG.key_schema">key_schema</a></code></li>
<li><code><a title="scenographer.relations.RelationDAG.load" href="#scenographer.relations.RelationDAG.load">load</a></code></li>
<li><code><a title="scenographer.relations.RelationDAG.tables" href="#scenographer.relations.RelationDAG.tables">tables</a></code></li>
<li><code><a title="scenographer.relations.RelationDAG.topologically_sorted" href="#scenographer.relations.RelationDAG.topologically_sorted">topologically_sorted</a></code></li>
<li><code><a title="scenographer.relations.RelationDAG.write_dot" href="#scenographer.relations.RelationDAG.write_dot">write_dot</a></code></li>
<li><code><a title="scenographer.relations.RelationDAG.write_plot" href="#scenographer.relations.RelationDAG.write_plot">write_plot</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>